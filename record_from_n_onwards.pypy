import os
import numpy as np
import sounddevice as sd
import soundfile as sf
import time

SAMPLE_RATE = 44100
DURATION = 0.1  
TARGET_SAMPLES_PER_CLASS = 50  # total per class
TRAINING_DATA_DIR = "./training_data"

# Remaining classes only (you've already done 0-9 and a-v)
CLASSES = [chr(i) for i in range(ord('w'), ord('z')+1)] + ['space', 'enter', 'noise']

class AudioRecorder:
    def __init__(self, sample_rate=SAMPLE_RATE):
        self.sample_rate = sample_rate
        self.recording = []
        self.is_recording = False
        self.stream = None

    def start_recording(self, max_duration=10):
        self.recording = []
        self.is_recording = True
        start_time = time.time()

        def callback(indata, frames, time, status):
            if status:
                print(f"Audio status: {status}")
            if self.is_recording:
                self.recording.append(indata.copy())

        self.stream = sd.InputStream(
            callback=callback, channels=1, samplerate=self.sample_rate, blocksize=1024
        )
        self.stream.start()
        print("üéôÔ∏è Recording started...")
        while self.is_recording and (time.time() - start_time < max_duration):
            sd.sleep(100)

    def stop_recording(self):
        self.is_recording = False
        if self.stream:
            self.stream.stop()
            self.stream.close()
            self.stream = None
        return np.concatenate(self.recording).flatten() if self.recording else np.array([])


def create_directory_structure():
    os.makedirs(TRAINING_DATA_DIR, exist_ok=True)
    for class_name in CLASSES:
        class_dir = os.path.join(TRAINING_DATA_DIR, class_name)
        os.makedirs(class_dir, exist_ok=True)
        print(f"üìÅ Directory ensured: {class_dir}")


def record_realtime(class_name, sample_idx):
    print(f"\nüé¨ Recording sample {sample_idx + 1} for '{class_name}'")
    if class_name == "noise":
        print("üëâ Make any background noise in 2 seconds...")
    elif class_name == "space":
        print("üëâ Press the SPACE key in 2 seconds...")
    elif class_name == "enter":
        print("üëâ Press the ENTER key in 2 seconds...")
    else:
        print(f"üëâ Press the '{class_name}' key in 2 seconds...")

    time.sleep(3)

    recorder = AudioRecorder()
    recorder.start_recording(max_duration=DURATION)
    time.sleep(DURATION)
    audio = recorder.stop_recording()

    if len(audio) == 0 or np.max(np.abs(audio)) < 0.01:
        print(f"‚ö†Ô∏è Too quiet or empty audio for {class_name}, sample {sample_idx}")
        return None

    class_dir = os.path.join(TRAINING_DATA_DIR, class_name)
    filename = f"sample_{sample_idx}.wav"
    filepath = os.path.join(class_dir, filename)
    sf.write(filepath, audio, SAMPLE_RATE)
    print(f"‚úÖ Saved: {filepath}")
    return filepath


def main():
    print("üîÅ Resuming dataset collection (k to z + specials)")
    create_directory_structure()
    total_new_samples = 0

    for class_name in CLASSES:
        print(f"\n=== Recording class '{class_name}' ===")
        class_dir = os.path.join(TRAINING_DATA_DIR, class_name)
        existing_files = [f for f in os.listdir(class_dir) if f.endswith(".wav")]
        existing_count = len(existing_files)
        remaining = TARGET_SAMPLES_PER_CLASS - existing_count

        print(f"üóÇÔ∏è {existing_count} existing samples. Need {remaining} more.")

        for idx in range(existing_count, existing_count + remaining):
            filepath = None
            attempts = 0
            max_attempts = 3
            while filepath is None and attempts < max_attempts:
                filepath = record_realtime(class_name, idx)
                attempts += 1
                if filepath is None:
                    print(f"Retry {attempts}/{max_attempts} for '{class_name}', sample {idx}")
                    time.sleep(3)
            if filepath:
                total_new_samples += 1
            else:
                print(f"‚ùå Failed to record '{class_name}', sample {idx}")
            time.sleep(2)

        print(f"‚úÖ Completed {TARGET_SAMPLES_PER_CLASS} samples for '{class_name}'")

    print("\nüéâ All remaining data collection done!")
    print(f"Total new samples recorded: {total_new_samples}")


if __name__ == "__main__":
    main()
